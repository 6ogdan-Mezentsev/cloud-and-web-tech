# 2 лабораторная работа "DevOps" - настройка Dockerfile

## Задание

1. Написать “плохой” Dockerfile, в котором есть не менее трех “bad practices” по написанию докерфайлов.
2. Написать “хороший” Dockerfile, в котором эти плохие практики исправлены.
3. Описать каждую из плохих практик в плохом докерфайле, почему она плохая и как в хорошем она была исправлена, как исправление повлияло на результат.
4. Описать 2 плохих практики по работе с контейнерами (как даже используя хороший докерфайл можно накосячить именно в работе с контейнерами).

## Описание плохих практик для Dockerfile и их исправление:

Далее будет рассмотрены варинаты docker файлов (плохой/хороший) для создания контейнера с ручкой api на фреймворке Express.

### 1. Использование тяжёлого базового образа ubuntu:latest

```
FROM ubuntu:latest
```

Почему плохо:

Образ Ubuntu весит несколько сотен мегабайт и в нём находится много ненужных системных пакетов.
Из-за этого увеличивается время сборки и загрузки контейнера.

Как исправить:

```
FROM node:18-alpine
```

Используем официальный образ node:18-alpine, который уже содержит Node.js и npm. В таком варианте размер образа сократился примерно в 10 раз (с ~400 МБ до ~40 МБ).
И сборка контейнера стала быстрее.

### 2. Установка Node.js вручную через apt

```
RUN apt update && apt install -y nodejs npm
```

Почему плохо:

Устанавливаются зависимости вручную, без фиксации версий, так как версии могут отличаться, то могут возникнуть конфликты.
Также после установки в образе остаётся кеш apt, увеличивающий размер образа.

Как исправить:

В node:18-alpine Node.js и npm уже установлены официально и хорошо оптимизированы.

Кеш не создаётся и поэтому размер образа остается минимальным.

### 3. Установка всех зависимостей или только необходимых для прода

```
RUN npm install
```

Устанавливает все зависимости из package.json

Почему плохо:

Образ становится тяжелее, а сборка контейнера дольше, и внутри контейнера появляются ненужные библиотеки, которые не нужны на продакшене.

Как исправить:

```
RUN npm install --production
```

Устанавливаются только рабочие зависимости из раздела "dependencies" в package.json

Контейнер получается меньше по размеру, быстрее собирается и содержит только то, что нужно для работы приложения.

### 4. Не указан EXPOSE

Без указания параметра EXPOSE в docker файле будет не понятно, какой порт слушает приложение.\
При запуске контейнера через docker run или docker-compose может быть сложно правильно пробросить нужный порт(и это просто лишние действия).

Как исправить:

```
EXPOSE 8001
```

## Описание плохих практик при работе с контейнерами через docker compose:

1. Работа с данными без использования volume или маунтов

```
services:
  app:
    image: myapp
    container_name: bad_container
    command: ["node", "index.js"]
```

Почему плохо:

Если данные приложения (например, логи, база данных) хранятся внутри контейнера, они исчезают при его пересоздании.\
Контейнер это по сути временная среда, и при каждом docker compose down или docker rm файловая система очищается.

```
services:
  app:
    image: myapp
    container_name: bad_container
    command: ["node", "index.js"]
```

Как исправить:

```
services:
  app:
    image: myapp
    container_name: good_container
    command: ["node", "index.js"]
    volumes:
      - ./data:/app/data   # сохраняем файлы локально
```

2. Хранение чувствительных и секретных данных внутри контейнера

```
ENV DB_PASSWORD=mysecretpassword
```

Почему плохо:

Добавление паролей, токенов или ключей API прямо в docker compose файлах это большая проблема.\
Так как при публикации образа на GitHub(или лююой другой удаленный репозиторий) такие данные становятся общедоступными, что не есть хорошо.

Как исправить:

```
services:
  app:
    image: myapp
    env_file:
      - .env  # указываем путь к env-файлу
```

3. Отсутствие отдельной docker-сети для контейнеров

```
services:
  api:
    image: myapi
  frontend:
    image: myfrontend
```

Контейнер frontend не сможет обратиться к api по имени api, а только по IP, который может меняться.

Почему плохо:

Если контейнеры не объединены в одну сеть, они не могут обращаться друг к другу по имени сервиса (например, api или db).\
Из-за этого приходится вручную настраивать IP-адреса или порты — что неудобно и ненадежно.

Как исправить:

```
services:
  api:
    image: myapi
    networks:
      - app_net

  frontend:
    image: myfrontend
    networks:
      - app_net

networks:
  app_net:
    driver: bridge
```

## Вывод

Рассмотренные практики(best practices) позволяют создавать лёгкие и безопасные образы, эффективно управлять данными контейнеров, обеспечивать их взаимодействие через сеть и защищать конфиденциальную информацию.
